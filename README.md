# SOLID 나만의 언어로 표현하기

---
| 원칙 | 정의 | 설명                                                                                                                                                                                                          |
|-----|-----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **S** - 단일 책임 원칙 (Single Responsibility Principle) | 하나의 클래스는 하나의 책임만 가져야 한다. | 클라이언트 격인 개발자 '우리'가 객체들에게 역할을 부여하고 명확히 지시할 수 있어야 하는 원칙이다. 객체를 인격으로 대하자. 엉뚱한 일을 시키지 말자.                                                                                                                       
| **O** - 개방-폐쇄 원칙 (Open-Closed Principle) | 기존 코드를 변경하지 않고 기능을 확장할 수 있어야 한다. | 절차지향이든 객체지향이든 하드코딩을 지양하고 싶어지는 원칙이다. 불변의 상수라면 어쩔 수 없지만, 그렇지 않을 가능성이 있다면 확장가능성을 염두에두고 하드코딩을 지양하자. 다만, 객체지향의 세계에서는 객체가 객체를 부를때 추상화 수준이 높은 객체를 부를 수 있는 다형성을 가지고 있으므로 이를 활용하여 저수준의 구현부를 변경하지 않고도 기능이 동작하게끔 노력하자. 
| **L** - 리스코프 치환 원칙 (Liskov Substitution Principle) | 하위 클래스는 상위 클래스의 기능을 깨뜨리지 않고 확장해야 한다. | 인터페이스든 추상클래스든 상위클래스로 넘어온 구체클래스에 대해서 분기처리를 하지 말게 하자. 상위 클래스를 정의할 수 있는 이유는 **같은 범주**로 여길 수 있기 때문이다. 그렇지 않으면 설계가 잘못된 것! | 
| **I** - 인터페이스 분리 원칙 (Interface Segregation Principle) | 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하면 안 된다. | 굳이 사용하지도 않는 상위 인터페이스의 메서드를 쓸 필요가 없다면 왜 해당 인터페이스를 구현해야하는가? 대답할 수 없다면 쪼개라! 어쩌면 SRP원칙과 비슷할 수도 있겠다. | 
| **D** - 의존 역전 원칙 (Dependency Inversion Principle) | 고수준 모듈이 저수준 모듈에 의존하면 안 된다. | 추상화된 클래스는 사실 구체화된 로직들을 Runtime엔 '결국' 바라봐야 하겠지만 이를 코드상에서도 바라볼 필요는 없다. 구현체를 코드에 구현하지 않고 좀더 고수준의 추상화된 클래스를 의존하게 된다면 OCP와 비슷한 느낌으로 변경에 매우 용이한 코드를 작성할 수 있다.
